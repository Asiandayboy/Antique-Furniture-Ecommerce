package api

import (
	"backend/db"
	"backend/types"
	"backend/util"
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/stripe/stripe-go/v76"
	stripeSession "github.com/stripe/stripe-go/v76/checkout/session"
	"github.com/stripe/stripe-go/v76/file"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

/*
- Client presses checkout button
- Server reads from request to get data?
- Server create checkout session and redirects
- Server listens for checkout session completed to give receipt
- Server saves appropriate data
*/

const domain string = "http://localhost:5173"

// User gets 95% of their profits; platform gets the other 5%
const REVENUE_SPLIT float64 = 0.95

const (
	ErrCheckoutSession = "Error creating checkout session"
)

type PaymentInfo struct {
	PaymentMethod string  `json:"paymentMethod"`
	Amount        float32 `json:"amount"`
	Currency      string  `json:"currency"`
}

type ShippingAddress struct {
	State   string `bson:"state" json:"state"`
	City    string `bson:"city" json:"city"`
	Street  string `bson:"street" json:"street"`
	ZipCode string `bson:"zipCode" json:"zipCode"`
}

type CheckoutInfo struct {
	ShoppingCart    []string        `json:"shoppingCart"`
	Payment         PaymentInfo     `json:"paymentInfo"`
	ShippingAddress ShippingAddress `json:"shippingAddress"`
}

type ProductItem struct {
	// ID of the furniture listing
	ListingID primitive.ObjectID `bson:"listingid" json:"listingId"`
	// ID of the user who posted the furniture listing; the seller
	SellerID primitive.ObjectID `bson:"sellerid" json:"sellerId"`
}

type Receipt struct {
	OrderID           primitive.ObjectID `bson:"_id,omitempty" json:"orderId"` // generated by mongo
	ShippingAddress   ShippingAddress    `bson:"shippingAddress" json:"shippingAddress"`
	PaymentMethod     string             `bson:"paymentMethod" json:"paymentMethod"`
	TotalCost         float32            `bson:"totalCost" json:"totalCost"`
	Items             []ProductItem      `bson:"items" json:"items"`
	UserID            primitive.ObjectID `bson:"userid" json:"userId"` // ID of buyer
	DatePurchased     time.Time          `bson:"datePurchased" json:"datePurchased"`
	EstimatedDelivery time.Time          `bson:"estimatedDelivery" json:"estimatedDelivery"`
}

/*
Creates a checkout session from Stripe's API, which redirects the client
to Stripe's hosted page to collect their payment infomation

Stripe servers will then process the payment once the client submits the form
*/
func (s *Server) HandleCheckout(w http.ResponseWriter, r *http.Request) {
	var input CheckoutInfo
	err := util.ReadJSONReq[CheckoutInfo](r, &input)
	if err != nil {
		http.Error(w, "Failed to decode request body", http.StatusBadRequest)
		return
	}

	// query DB with list of listingIDs in shopping cart
	var listingIDsToRetrieve []primitive.ObjectID
	for _, listingID := range input.ShoppingCart {
		objID, err := primitive.ObjectIDFromHex(listingID)
		if err != nil {
			http.Error(w, primitive.ErrInvalidHex.Error(), http.StatusBadRequest)
			return
		}

		listingIDsToRetrieve = append(listingIDsToRetrieve, objID)
	}
	listingsCollection := db.GetCollection("listings")
	filter := bson.M{"_id": bson.M{"$in": listingIDsToRetrieve}}
	cursor, err := listingsCollection.Find(context.Background(), filter)
	if err != nil {
		http.Error(w, "Error getting listings", http.StatusBadGateway)
		return
	}

	// extract documents from cursor into an array
	var furnitures []types.FurnitureListing
	for cursor.Next(context.Background()) {
		var furnitureListing types.FurnitureListing
		if err := cursor.Decode(&furnitureListing); err != nil {
			log.Printf("Error decoding document: %v", err)
			continue
		}
		furnitures = append(furnitures, furnitureListing)
	}

	// fmt.Println("Description:", furnitures[0])

	if err := cursor.Err(); err != nil {
		http.Error(w, "Error fetching furnitures", http.StatusBadRequest)
		return
	}

	/*-------------STRIPE-------------*/

	stripe.Key = os.Getenv("STRIPE_TEST_KEY")

	// create Stripe checkout session
	var lineItems []*stripe.CheckoutSessionLineItemParams
	for _, furniture := range furnitures {
		// upload furniture images to stripe to get URLs
		var imageURLs []*string
		for i, imgData := range furniture.Images {
			imageParams := &stripe.FileParams{
				Purpose:    stripe.String(string(stripe.FilePurposeDisputeEvidence)),
				FileReader: strings.NewReader(string(imgData)),
				Filename:   stripe.String(fmt.Sprintf("image%d", i+1)),
			}

			upload, err := file.New(imageParams)
			if err != nil {
				http.Error(
					w,
					fmt.Sprintf("Failed to upload image file %d to Stripe: %s\n", i+1, err),
					http.StatusInternalServerError,
				)
				return
			}
			imageURLs = append(imageURLs, stripe.String(upload.URL)) // APPARENTLY, THE LINKS ARE BROKEN?

			// fmt.Printf("Links?: %v\n", upload.Links)
		}

		productData := &stripe.CheckoutSessionLineItemPriceDataProductDataParams{
			Name:        &furniture.Title,
			Description: &furniture.Description,
			Metadata: map[string]string{
				"Material":  string(furniture.Type),
				"Condition": string(furniture.Material),
				"Style":     string(furniture.Style),
				"ListingID": furniture.ListingID.Hex(),
			},
			Images: imageURLs,
		}

		lineItems = append(lineItems, &stripe.CheckoutSessionLineItemParams{
			PriceData: &stripe.CheckoutSessionLineItemPriceDataParams{
				Currency:          stripe.String(input.Payment.Currency),
				ProductData:       productData,
				UnitAmountDecimal: stripe.Float64(furniture.Cost * 100),
			},
			Quantity: stripe.Int64(1),
		})
	}

	session := r.Context().Value(SessionKey).(*Session)

	shoppingCardJSONData, err := json.Marshal(input.ShoppingCart)
	if err != nil {
		http.Error(w, "Failed to encode listingIDs into JSON", http.StatusBadRequest)
		return
	}

	shippingAddressJSONData, err := json.Marshal(input.ShippingAddress)
	if err != nil {
		http.Error(w, "Failed to encode shipping address into JSON", http.StatusBadRequest)
		return
	}

	params := &stripe.CheckoutSessionParams{
		LineItems:  lineItems,
		Mode:       stripe.String(string(stripe.CheckoutSessionModePayment)),
		SuccessURL: stripe.String(domain + "/checkout_success"), // frontend page
		CancelURL:  stripe.String(domain + "/checkout_cancel"),  // frontend page

		/*
			This is how we're passing the sessionID; we will access this in the webhook
			handler so we can authenticate the user and fulfill the order by saving
			necessary information associated with the client, like receipts and stuff
		*/
		Metadata: map[string]string{
			"sessionID":       session.SessionID,
			"userID":          session.Store["userid"].(primitive.ObjectID).Hex(),
			"listingIDs":      string(shoppingCardJSONData),
			"paymentMethod":   input.Payment.PaymentMethod,
			"shippingAddress": string(shippingAddressJSONData),
		},
	}

	checkoutSession, err := stripeSession.New(params)
	if err != nil {
		http.Error(w, ErrCheckoutSession, http.StatusInternalServerError)
		return
	}

	fmt.Println("Checkout session link:", checkoutSession.URL) // printing for testing purposes

	http.Redirect(w, r, checkoutSession.SuccessURL, http.StatusSeeOther)
}

/*
Calculates the actual amount received by the platform after Stripe's processing
fee of 2.9% + 30 cents for each successful transaction
*/
func afterStripeFee(amountPaid float64) float64 {
	return amountPaid - (amountPaid * 0.029) + 0.30
}

/*
Processes webhook requests from Stripe's API.

When something interesting--an event--happens in Stripe, Stripe's server
sends a webhook request to your endpoint, sending data of the event

This handler is used to update the user's account after a successful
checkout and returns necessary information to the client, like their receipt
*/
func (s *Server) HandleStripeWebhook(w http.ResponseWriter, r *http.Request) {
	// extract the Stripe Event obj from the request body
	var event stripe.Event
	if err := util.ReadJSONReq[stripe.Event](r, &event); err != nil {
		fmt.Fprintf(os.Stderr, "Failed to parse webhook body json: %v\n", err.Error())
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	fmt.Println(event.Type)

	switch event.Type {
	case stripe.EventTypeCheckoutSessionCompleted:
		var checkoutSession stripe.CheckoutSession
		err := json.Unmarshal(event.Data.Raw, &checkoutSession)
		if err != nil {
			log.Printf("Error parsing webhook JSON: %v\n", err.Error())
			return
		}

		metadata := checkoutSession.Metadata

		sessionManager := GetSessionManager()
		session, sessionExists := sessionManager.GetSession(metadata["sessionID"])
		if !sessionExists {
			log.Println("Cannot find sessionID given metadata")
			return
		}

		fmt.Printf("Session of user: %s\n", session.SessionID)
		fmt.Println("Amount paid:", checkoutSession.AmountTotal/100)

		/*----------------------Receipts, update balances, etc------------------------*/

		var shippingAddress ShippingAddress
		err = json.Unmarshal([]byte(metadata["shippingAddress"]), &shippingAddress)
		if err != nil {
			log.Println("Failed to decode shipping address")
			return
		}
		userID, _ := primitive.ObjectIDFromHex(metadata["userID"])

		orderReceipt := Receipt{
			Items:             []ProductItem{},
			TotalCost:         float32(checkoutSession.AmountTotal) / 100,
			DatePurchased:     time.Now(),
			EstimatedDelivery: time.Now().AddDate(0, 1, 0), // defaulting to 1 month estimated delivery for testing
			PaymentMethod:     metadata["paymentMethod"],
			UserID:            userID,
			ShippingAddress:   shippingAddress,
		}

		var listingIDs []string
		if err := json.Unmarshal([]byte(metadata["listingIDs"]), &listingIDs); err != nil {
			log.Println("Failed to decode listingIDs from JSON")
			return
		}

		// use listingIDs to update each seller's data
		for _, id := range listingIDs {
			var furnitureListing types.FurnitureListing
			listingID, _ := primitive.ObjectIDFromHex(id)
			listingsCollection := db.GetCollection("listings")
			_ = listingsCollection.FindOne(context.Background(), bson.M{"_id": listingID}).Decode(&furnitureListing)

			// update the seller's virtual balance
			var seller types.User
			usersCollection := db.GetCollection("users")
			_ = usersCollection.FindOne(
				context.Background(),
				bson.M{"_id": furnitureListing.UserID},
			).Decode(&seller)

			/*-----------TODO: Don't forget to mark listing as "bought": true-------------*/
			/*---------------------Leave it as false for testing, though------------------*/
			/*-------------------------------2/4/2024-------------------------------------*/

			amountReceivedByPlatform := afterStripeFee(float64(checkoutSession.AmountTotal / 100))
			amountReceivedByUser := amountReceivedByPlatform * REVENUE_SPLIT
			seller.UpdateBalance(amountReceivedByUser)

			// save user's updated balance into database
			res, err := usersCollection.UpdateOne(
				context.Background(),
				bson.M{"_id": seller.UserID},
				bson.M{"$set": bson.M{"balance": seller.Balance}},
			)
			if err != nil {
				log.Printf("Could not update user's %v balance: %s\n", res.UpsertedID, err.Error())
				return
			}

			// add each item to receipt
			orderReceipt.Items = append(orderReceipt.Items, ProductItem{
				ListingID: listingID,
				SellerID:  seller.UserID,
			})
		}

		// save receipt into database
		receiptsCollection := db.GetCollection("receipts")
		_, err = receiptsCollection.InsertOne(context.Background(), orderReceipt)
		if err != nil {
			log.Println("Failed to insert receipt into database:", err.Error())
			return
		}

	}

}
